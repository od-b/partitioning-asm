## Array Partitioning, Handwritten Assembly vs. GCC

Optimizing quicksort partitioning in assembly can lead to 5-10% performance gains over C code produced through gcc/clang, and reduce code size by more than 90%.

This is mostly done through obscure methods, such as reordering of instructions to better fill the pipeline.

See bench/arm_vs_c.time for results, or run the program yourself.

**The program has three alternate main files:**

* **test.c**  
Mainly consists of tests and assertions. Takes no command line arguments.  
When compiled using `test.c`, a series of tests and assertions will run in order to verify the integrity of the sorting algorithm.  
These tests will run **either** the assembly or C implementation, depending on which **partition function** is called within `void quicksort(...)`. (The assembly function is set by default.)  

* **bench.c**  
Completely debloated program, intended to provide fair grounds for timing execution with minimal overhead.  
usage: `quicksort <arr_count> <val_lim> <n_runs> <seed> <run_asm: bool>`  
Explanation of arguments:  
    * `arr_count`: sets the length, aka. size/count of the to-be generated arrays. 
    * `val_lim`: limit value of array elements generated by `rand()`. `val_lim=0` equals `RAND_MAX`, which typically equals `INT_MAX`, or 2147483647.  
    * `n_runs`: sets how many runs to perform. Each generated array will have a new selection of pseudo-random values.  
    * `seed`: seed for `rand()`. Should be the same for both implementations to assure fair comparison.  
    * `run_asm`: boolean, controls whether to run the assembly or C implementation of the partitioning function.  

To select which version of the program to run, change the `CFILE` variable within the *Makefile*.  
The makefile also contains a `ASMFILE` variable, however, this does not need to to be changed between the implementations.
Change it in order to run a different `<asm filename>.S` file, e.g. to `asm_partition_initial`.

> Note: On tested architecture, both emulated and native, -O2 performed best by a wide margin. 


* **throughput.c**  
Naive simulation of what instructions are being performed for any given array, and the total 
theoretical reciprocal throughput of the program. Adjustable RT weights. Run with -O0 ideally.  
Does not depend on any asm file(s). Calculations based on `asm_partitions.S`.  


<br>

### time_exec.sh
Simple shell script to make and run both implementations, timing each implementation separately.  
When run, the output of `time` is appended to the set `OUTFILE`.  
This script is intended to be executed with `CFILE=bench` set within the Makefile.
